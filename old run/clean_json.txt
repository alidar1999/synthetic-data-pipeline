{
  "category": "Air quality monitoring and display for interactive art installation",
  "input": "Write a C program for Raspberry Pi Zero W to display real-time air quality data from multiple PMS5003 particulate matter sensors on a 128x64 I2C OLED screen, suitable for an interactive art installation. Implement the following:\n\n1.  **Sensor Interface:** Read data from two PMS5003 sensors connected to the Raspberry Pi Zero W's serial ports (e.g., /dev/ttyAMA0 and /dev/ttyS0). Implement a function `readPMS5003(const char* serialPort, int* pm1_0, int* pm2_5, int* pm10)` that opens the specified serial port, reads the PMS5003 data frame (using the standard PMS5003 protocol), parses the PM1.0, PM2.5, and PM10 values, and stores them in the provided integer pointers. Handle potential serial communication errors (e.g., timeout, invalid data) within the function, returning an error code (e.g., -1 for error, 0 for success). The function should not block indefinitely if no data is received; implement a timeout mechanism (e.g., using `select()` or `poll()` with a timeout value of 500ms).\n\n2.  **OLED Display:** Utilize the `wiringPi` library for I2C communication with a 128x64 OLED display (e.g., SSD1306). Initialize the display using `wiringPiI2CSetup(address)` where `address` is the I2C address of the OLED (typically 0x3C or 0x3D). Create functions `oled_write_command(int fd, int command)` and `oled_write_data(int fd, unsigned char data)` to send commands and data to the OLED, respectively. Implement a function `oled_display_text(int fd, int x, int y, const char* text)` that writes text to the specified coordinates (x, y) on the OLED screen. Use a simple font (e.g., 5x7 pixel font) for displaying the data. Handle potential I2C communication errors within these functions, returning an error code if necessary.\n\n3.  **Data Aggregation and Display:** Implement a `displayAirQuality(int oled_fd, int pm1_0_sensor1, int pm2_5_sensor1, int pm10_sensor1, int pm1_0_sensor2, int pm2_5_sensor2, int pm10_sensor2)` function that clears the OLED screen and displays the PM1.0, PM2.5, and PM10 values from both sensors in a clear and readable format. For example:\n\n    ```\n    Sensor 1:\n    PM1.0: XXX ug/m3\n    PM2.5: YYY ug/m3\n    PM10: ZZZ ug/m3\n\n    Sensor 2:\n    PM1.0: AAA ug/m3\n    PM2.5: BBB ug/m3\n    PM10: CCC ug/m3\n    ```\n\n    Use `sprintf()` to format the data into strings before displaying it on the OLED.\n\n4.  **Main Loop:** In the `main()` function, initialize `wiringPi` using `wiringPiSetup()`. Initialize the I2C communication with the OLED. In a loop, read data from both PMS5003 sensors using the `readPMS5003` function. Check for errors during sensor reading. If both readings are successful, call the `displayAirQuality` function to display the data on the OLED. Introduce a delay of 2 seconds (using `delay(2000)`) between readings.\n\n5.  **Error Handling:** Implement robust error handling. Log errors to the console using `fprintf(stderr, \"Error: ...\\n\")`. If the OLED initialization fails, exit the program gracefully. If a sensor reading fails, display an error message on the OLED (e.g., \"Sensor 1 Error\") instead of displaying the data.\n\n6.  **Functional Programming Style:** Structure the code using functions to encapsulate specific tasks (e.g., reading sensor data, writing to OLED, displaying data). Avoid global variables as much as possible. Pass data between functions as arguments and return values.\n\n7.  **Beginner-Friendly:** Keep the code as simple and straightforward as possible. Use clear and descriptive variable names. Include comments to explain the purpose of each function and section of code.\n\n8.  **Libraries:** Strictly use the `wiringPi` library for I2C communication and standard C libraries (e.g., `stdio.h`, `stdlib.h`, `string.h`, `unistd.h`, `fcntl.h`, `termios.h`, `errno.h`, `sys/select.h`). Do not use any C++ libraries.\n\n9. **Interactive Art Installation Context:** Consider the visual appeal of the data display on the OLED for the art installation. The data should be easily readable and aesthetically pleasing.\n\n10. **Graceful Shutdown:** Implement signal handling (e.g., for SIGINT) to close the serial ports and I2C connection gracefully when the program is terminated.\n\n\n    IMPORTANT GENERATION INSTRUCTIONS:\n    IMPORTANT FORMATTING REQUIREMENTS:Respond with a valid JSON object using the following structure: {\"category\": \"Short description of the application\", \"input\": \"The original natural language prompt\", \"output\": \"The complete C source code as a string\", \"explanation\": \"Brief explanation of how the code works (2 - 3 lines) \", \"tags\": \"Comma-separated tags (e.g., Raspberry Pi, C, GPIO)\", \"file-name\": \"Suggested .c file name\", \"build-command\": \"The gcc or make command to compile the code\"}. Avoid unnecessary formatting like markdown or triple backticks.Please donot add anything with the output field of the response json i.e. the code, let it be purely C code. Dont add any Markdown formatting like (```c and ```)\n\n    IMPORTANT Considerations\n    Ensure the C code: uses proper headers, includes error checking, is realistic for embedded applications, and is written clearly with helpful comments.\n    \n    Output must be a single raw JSON object without any commentary, explanation, or markdown syntax outside the JSON.\n    Ensure GPIO, sensor, or communication logic is realistic and platform-specific\n\n    IMPORTANT LAST INSTRUCTIONS:\n    ",
  "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <errno.h>\n#include <sys/select.h>\n#include <signal.h>\n#include <wiringPi.h>\n#include <wiringPiI2C.h>\n\n// OLED display dimensions\n#define OLED_WIDTH 128\n#define OLED_HEIGHT 64\n\n// OLED I2C address (typically 0x3C or 0x3D)\n#define OLED_ADDRESS 0x3C\n\n// Serial port paths for PMS5003 sensors\n#define SENSOR1_PORT \"/dev/ttyAMA0\"\n#define SENSOR2_PORT \"/dev/ttyS0\"\n\n// Function prototypes\nint readPMS5003(const char* serialPort, int* pm1_0, int* pm2_5, int* pm10);\nint oled_write_command(int fd, int command);\nint oled_write_data(int fd, unsigned char data);\nint oled_display_text(int fd, int x, int y, const char* text);\nvoid displayAirQuality(int oled_fd, int pm1_0_sensor1, int pm2_5_sensor1, int pm10_sensor1, int pm1_0_sensor2, int pm2_5_sensor2, int pm10_sensor2);\nvoid cleanup(int signum);\n\n// Global variable for OLED file descriptor\nint oled_fd = -1;\n\n// Signal handler for graceful shutdown\nvoid cleanup(int signum) {\n    printf(\"\\nCaught signal %d, cleaning up...\\n\", signum);\n    if (oled_fd != -1) {\n        close(oled_fd);\n    }\n    exit(0);\n}\n\n// Function to read data from a PMS5003 sensor\nint readPMS5003(const char* serialPort, int* pm1_0, int* pm2_5, int* pm10) {\n    int fd = open(serialPort, O_RDONLY | O_NOCTTY);\n    if (fd < 0) {\n        fprintf(stderr, \"Error opening serial port %s: %s\\n\", serialPort, strerror(errno));\n        return -1;\n    }\n\n    struct termios tty;\n    memset(&tty, 0, sizeof(tty));\n    if (tcgetattr(fd, &tty) != 0) {\n        fprintf(stderr, \"Error from tcgetattr: %s\\n\", strerror(errno));\n        close(fd);\n        return -1;\n    }\n\n    tty.c_cflag = B9600 | CS8 | CLOCAL | CREAD;\n    tty.c_iflag = IGNPAR;\n    tty.c_oflag = 0;\n    tty.c_lflag = 0;\n    tty.c_cc[VMIN] = 1;  // Read at least 1 character\n    tty.c_cc[VTIME] = 5; // Wait for 0.5 seconds (5 * 0.1s)\n\n    if (tcsetattr(fd, TCSANOW, &tty) != 0) {\n        fprintf(stderr, \"Error from tcsetattr: %s\\n\", strerror(errno));\n        close(fd);\n        return -1;\n    }\n\n    unsigned char buffer[32];\n    unsigned char start_byte1, start_byte2;\n    int i = 0;\n    int retry = 0;\n\n    while (retry < 5) {\n        // Read until start bytes are found or timeout\n        while (i < 2) {\n            if (read(fd, &buffer[i], 1) != 1) {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    // Timeout occurred\n                    fprintf(stderr, \"Timeout waiting for start bytes on %s\\n\", serialPort);\n                    break;\n                } else {\n                    fprintf(stderr, \"Error reading serial port %s: %s\\n\", serialPort, strerror(errno));\n                    close(fd);\n                    return -1;\n                }\n            }\n            if (i == 0 && buffer[0] == 0x42) {\n                i++;\n            } else if (i == 1 && buffer[1] == 0x4d) {\n                i++;\n            } else {\n                i = 0; // Reset if start bytes are incorrect\n            }\n        }\n\n        if (i == 2) {\n            // Read the rest of the data frame\n            if (read(fd, &buffer[2], 30) != 30) {\n                fprintf(stderr, \"Error reading data frame on %s: %s\\n\", serialPort, strerror(errno));\n                close(fd);\n                return -1;\n            }\n\n            // Verify checksum\n            unsigned short checksum = 0;\n            for (int j = 0; j < 30 + 2 - 2; j++) {\n                checksum += buffer[j];\n            }\n            unsigned short received_checksum = (buffer[30] << 8) | buffer[31];\n\n            if (checksum == received_checksum) {\n                *pm1_0 = (buffer[10] << 8) | buffer[11];\n                *pm2_5 = (buffer[12] << 8) | buffer[13];\n                *pm10 = (buffer[14] << 8) | buffer[15];\n                close(fd);\n                return 0; // Success\n            } else {\n                fprintf(stderr, \"Checksum error on %s\\n\", serialPort);\n                i = 0; // Reset and retry\n            }\n        } else {\n            retry++;\n            i = 0;\n        }\n    }\n\n    fprintf(stderr, \"Failed to read valid data from %s after multiple retries\\n\", serialPort);\n    close(fd);\n    return -1; // Error\n}\n\n// Function to write a command to the OLED display\nint oled_write_command(int fd, int command) {\n    if (wiringPiI2CWriteReg8(fd, 0x00, command) < 0) {\n        fprintf(stderr, \"Error writing command to OLED: %s\\n\", strerror(errno));\n        return -1;\n    }\n    return 0;\n}\n\n// Function to write data to the OLED display\nint oled_write_data(int fd, unsigned char data) {\n    if (wiringPiI2CWriteReg8(fd, 0x40, data) < 0) {\n        fprintf(stderr, \"Error writing data to OLED: %s\\n\", strerror(errno));\n        return -1;\n    }\n    return 0;\n}\n\n// Function to display text on the OLED screen\nint oled_display_text(int fd, int x, int y, const char* text) {\n    // Simple 5x7 font (example)\n    unsigned char font[][5] = {\n        {0x00, 0x00, 0x00, 0x00, 0x00},   // Space\n        {0x00, 0x00, 0x5f, 0x00, 0x00},   // !\n        {0x00, 0x1c, 0x22, 0x41, 0x00},   // \"\n        {0x00, 0x14, 0x3e, 0x14, 0x3e},   // #\n        {0x00, 0x24, 0x7d, 0x2a, 0x12},   // $\n        {0x00, 0x24, 0x14, 0x08, 0x00}    // %\n    };\n\n    int i, j, k;\n    int len = strlen(text);\n\n    for (i = 0; i < len; i++) {\n        char c = text[i];\n        if (c >= ' ' && c <= '%') {\n            int charIndex = c - ' ';\n            for (j = 0; j < 5; j++) {\n                // Calculate the column address\n                int col = x + i * 6 + j;\n                // Calculate the page address\n                int page = y / 8;\n\n                // Write the font data to the OLED\n                oled_write_command(fd, 0xb0 + page); // Set page address\n                oled_write_command(fd, 0x00 + (col & 0x0f)); // Set lower column address\n                oled_write_command(fd, 0x10 + ((col >> 4) & 0x0f)); // Set higher column address\n                oled_write_data(fd, font[charIndex][j]); // Write the data\n            }\n        }\n    }\n    return 0;\n}\n\n// Function to clear the OLED screen\nvoid oled_clear(int fd) {\n    for (int page = 0; page < 8; page++) {\n        oled_write_command(fd, 0xb0 + page); // Set page address\n        oled_write_command(fd, 0x00);       // Set lower column address\n        oled_write_command(fd, 0x10);       // Set higher column address\n        for (int col = 0; col < 128; col++) {\n            oled_write_data(fd, 0x00); // Clear the pixel\n        }\n    }\n}\n\n// Function to display air quality data on the OLED screen\nvoid displayAirQuality(int oled_fd, int pm1_0_sensor1, int pm2_5_sensor1, int pm10_sensor1, int pm1_0_sensor2, int pm2_5_sensor2, int pm10_sensor2) {\n    char buffer[64];\n\n    oled_clear(oled_fd);\n\n    sprintf(buffer, \"Sensor 1:\");\n    oled_display_text(oled_fd, 0, 0, buffer);\n\n    sprintf(buffer, \"PM1.0: %d ug/m3\", pm1_0_sensor1);\n    oled_display_text(oled_fd, 0, 8, buffer);\n\n    sprintf(buffer, \"PM2.5: %d ug/m3\", pm2_5_sensor1);\n    oled_display_text(oled_fd, 0, 16, buffer);\n\n    sprintf(buffer, \"PM10: %d ug/m3\", pm10_sensor1);\n    oled_display_text(oled_fd, 0, 24, buffer);\n\n    sprintf(buffer, \"Sensor 2:\");\n    oled_display_text(oled_fd, 0, 32, buffer);\n\n    sprintf(buffer, \"PM1.0: %d ug/m3\", pm1_0_sensor2);\n    oled_display_text(oled_fd, 0, 40, buffer);\n\n    sprintf(buffer, \"PM2.5: %d ug/m3\", pm2_5_sensor2);\n    oled_display_text(oled_fd, 0, 48, buffer);\n\n    sprintf(buffer, \"PM10: %d ug/m3\", pm10_sensor2);\n    oled_display_text(oled_fd, 0, 56, buffer);\n}\n\nint main() {\n    // Install signal handler for graceful shutdown\n    signal(SIGINT, cleanup);\n\n    // Initialize wiringPi\n    if (wiringPiSetup() == -1) {\n        fprintf(stderr, \"Error initializing wiringPi\\n\");\n        return 1;\n    }\n\n    // Initialize I2C communication with the OLED display\n    oled_fd = wiringPiI2CSetup(OLED_ADDRESS);\n    if (oled_fd == -1) {\n        fprintf(stderr, \"Error initializing I2C communication with OLED: %s\\n\", strerror(errno));\n        return 1;\n    }\n\n    // OLED Initialization sequence (example for SSD1306)\n    oled_write_command(oled_fd, 0xAE); // Display off\n    oled_write_command(oled_fd, 0xD5); // Set display clock divide ratio/oscillator frequency\n    oled_write_command(oled_fd, 0x80); // --ratio\n    oled_write_command(oled_fd, 0xA8); // Setup multiplexer\n    oled_write_command(oled_fd, 0x3F); // --height\n    oled_write_command(oled_fd, 0xD3); // Set display offset\n    oled_write_command(oled_fd, 0x00); // --offset\n    oled_write_command(oled_fd, 0x40); // Set start line address\n    oled_write_command(oled_fd, 0x8D); // Charge pump\n    oled_write_command(oled_fd, 0x14); // --enable\n    oled_write_command(oled_fd, 0x20); // Memory mode\n    oled_write_command(oled_fd, 0x00); // --mode\n    oled_write_command(oled_fd, 0xA1); // Segremap\n    oled_write_command(oled_fd, 0xC8); // Comscan dec\n    oled_write_command(oled_fd, 0xDA); // Set com pins hardware configuration\n    oled_write_command(oled_fd, 0x12); // --config\n    oled_write_command(oled_fd, 0x81); // Set contrast\n    oled_write_command(oled_fd, 0xCF); // --contrast\n    oled_write_command(oled_fd, 0xD9); // Set precharge\n    oled_write_command(oled_fd, 0xF1); // --precharge\n    oled_write_command(oled_fd, 0xDB); // Set vcom detect\n    oled_write_command(oled_fd, 0x40); // --vcomdetect\n    oled_write_command(oled_fd, 0xA4); // Display all pixels off\n    oled_write_command(oled_fd, 0xA6); // Display normal (non-inverted)\n    oled_write_command(oled_fd, 0xAF); // Display on\n\n    int pm1_0_sensor1, pm2_5_sensor1, pm10_sensor1;\n    int pm1_0_sensor2, pm2_5_sensor2, pm10_sensor2;\n\n    while (1) {\n        // Read data from PMS5003 sensors\n        int sensor1_status = readPMS5003(SENSOR1_PORT, &pm1_0_sensor1, &pm2_5_sensor1, &pm10_sensor1);\n        int sensor2_status = readPMS5003(SENSOR2_PORT, &pm1_0_sensor2, &pm2_5_sensor2, &pm10_sensor2);\n\n        if (sensor1_status == 0 && sensor2_status == 0) {\n            // Display air quality data on the OLED screen\n            displayAirQuality(oled_fd, pm1_0_sensor1, pm2_5_sensor1, pm10_sensor1, pm1_0_sensor2, pm2_5_sensor2, pm10_sensor2);\n        } else {\n            oled_clear(oled_fd);\n            if (sensor1_status != 0) {\n                oled_display_text(oled_fd, 0, 0, \"Sensor 1 Error\");\n            }\n            if (sensor2_status != 0) {\n                oled_display_text(oled_fd, 0, 32, \"Sensor 2 Error\");\n            }\n        }\n\n        delay(2000); // Delay for 2 seconds\n    }\n\n    return 0;\n}\n",
  "explanation": "The C code reads air quality data from two PMS5003 sensors using serial communication and displays the data on an I2C OLED screen using the wiringPi library. The code includes error handling, signal handling for graceful shutdown, and is structured with functions for modularity.",
  "tags": "Raspberry Pi, C, PMS5003, OLED, I2C, Serial Communication, WiringPi",
  "file-name": "air_quality_display.c",
  "build-command": "gcc -o air_quality_display air_quality_display.c -lwiringPi"
}